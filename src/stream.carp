;; Copyright 2020 Google LLC
;;
;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;  https://www.apache.org/licenses/LICENSE-2.0
;;
;;  Unless required by applicable law or agreed to in writing, software
;;  distributed under the License is distributed on an "AS IS" BASIS,
;;  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;  See the License for the specific language governing permissions and
;;  limitations under the License.

(load "src/lazy.carp")

(doc Step "
  The Step type is the backing model for processing streams.")
(deftype (Step a s) (Done []) (Yield [a s]) (Skip [s]))

(defmodule Step
  (implements = =)
  (defn = [s s*]
    (match s
      (Step.Done)
        (match s*
          (Step.Done) true
          _ false)
      (Step.Skip t)
        (match s*
          ;; We append refs to = calls since many core types implement = for
          ;; refs, but not for values (e.g. array, maybe).
          ;; Most other types also have a ref = implementation (Int, etc.)
          (Step.Skip t*) (= &t &t*)
          _ false)
      (Step.Yield x u)
        (match s*
          (Step.Yield x* u*) (and (= &x &x*) (= &u &u*))
          _ false)))

  (doc skip? "
    Returns true if `step` is a `Skip`.")
  (sig skip? (Fn [(Step a s)] Bool))
  (defn skip? [step]
      (match step
        (Step.Skip s) true
        _ false))
)

(doc Node "
  The type of stream values.

  In order to return a safe bottom value when getting stream values, we need
  Node to avoid having to return Step directly.")
(deftype (Node a) (Nil []) (Node [a]))

(doc Stream "
  The type of Streams.

  Streams are backed by a `Step` returning function `next` and a current
  `state`. Stream processing functions run `next` on the current `state` to
  yield the remainder of the stream.")
(deftype (Stream a s) [next (Fn [(Ref s)] (Step a s)) state s])

(doc Unit "
  An opaque type representing the unit type.

  Carp has a notion of unit, but it is a special value, and not exposed as a
  type/module to the user.

  Since our lazy mechanisms rely on (zero) implementations, we provide this type
  as a stand-in for Carp's unit type, and implement zero on it.

  So, in much of this library, places where one would normally return (), return
  this type, Unit instead.")
(deftype Unit Unit)

(defmodule Unit
  (doc zero "
    Returns the opaque type, `Unit`.")
  (implements zero zero)
  (defn zero []
    (Unit.Unit))
)

(defmodule Node
  (doc zero "
    Returns the Nil node.")
  (implements zero zero)
  (defn zero []
    (Node.Nil))

  (todo = "TODO: Update once match-ref supports wildcards `_`")
  (implements = =)
  (defn = [n n*]
    (match-ref n
      (Node.Node x)
        (match-ref n*
          (Node.Node y) (= x y)
          (Node.Nil) false)
      (Node.Nil)
        (match-ref n*
          (Node.Nil) true
          (Node.Node z) false)))
)

(defmodule Stream
  (doc zero "
    The zero stream; comprised of a `next` that constantly returns `Step.Done`
    and the `zero` value for the stream's `state`.")
  (implements zero zero)
  (defn zero []
    (Stream.init (fn [s] (Step.Done)) (zero)))

  (implements = =)
  (defn = [s s*]
    (let [state-one (Stream.state s)
          state-two (Stream.state s*)
          next-one  (Stream.next s)
          next-two  (Stream.next s*)]
      (and (= state-one state-two)
           (= (~next-one state-one) (~next-two state-two)))))

  (doc from-array "
    Creates a stream from an array.")
  (sig from-array (Fn [(Ref (Array b))] (Stream (Maybe b) (Array b))))
  (defn from-array [as]
    (let [n (fn [s] (if (= 0 (Array.length s))
                        (Step.Done)
                        (Step.Yield (Array.nth s 0) (Array.suffix s 1))))]
      (Stream.init n @as)))

(doc advance "
    Returns a lazy computation that advances a stream in place.

    ```
    (def stream (from-array &[1 2 3]))
    (defn runstream [s] (let [_ (force &(advance s))] s))
    (do (runstream &stream) (runstream &stream))
    => (Stream [2 3]) ;; memoization
    (runstream (runstream &stream))
    (Stream [])
    ```")
  (sig advance (Fn [(Ref (Stream x s))] (Suspended Unit)))
  (defn advance [s]
    (Lazy.suspend
      (fn []
        (let [nx (Stream.next s)
              st (Stream.state s)]
          (match (~nx st)
                 (Step.Done) (Unit.Unit)
                 (Step.Skip t) (do (ignore (Stream.set-state! s t)) (Unit.Unit))
                 (Step.Yield x u) (do (ignore (Stream.set-state! s u))
                 (Unit.Unit)))))))

(doc !advance "
    Advances a stream in place eagerly.

    ```
    (def stream (from-array &[1 2 3]))
    (do (!advance &stream) (!advance &stream) stream)
    => (Stream [3])
    ```")
  (sig !advance (Fn [(Ref (Stream x s))] ()))
  (defn !advance [s]
    (let [nx (Stream.next s)
          st (Stream.state s)]
      (match (~nx st)
             (Step.Done) ()
             (Step.Skip t) (Stream.set-state! s t)
             (Step.Yield x u) (Stream.set-state! s u))))

  (doc head "
    Returns a lazy computation that returns the first element of a stream.")
  (sig head (Fn [(Ref (Stream x s))] (Suspended (Node x))))
  (defn head [s]
    (Lazy.suspend
      (fn []
        (let [nx (Stream.next s)
              st (Stream.state s)]
          (do
            (while (Step.skip? (~nx (Stream.state s)))
              (Stream.!advance s))
            (match (~nx (Stream.state s))
                   (Step.Yield x u) (Node.Node x)
                   _ (Node.Nil)))))))

  (doc tail "
    Returns a lazy computation that returns the tail of a stream.")
  (sig tail (Fn [(Ref (Stream x s))] (Suspended (Stream x s))))
  (defn tail [s]
    (Lazy.suspend
      (fn []
        (let [nx (Stream.next s)
              st (Stream.state s)]
          (match (~nx st)
                 (Step.Done) @s
                 (Step.Skip t) (Stream.init @nx t)
                 (Step.Yield x u) (Stream.init @nx u))))))

  (doc to-array "
    Converts a stream to an array.")
  (defn to-array [s]
    (let [res (Array.zero)
          stream @s]
    (do (while (not (= (~(Stream.next &stream) (Stream.state &stream)) (Step.Done)))
          (do (match (Lazy.force &(head &stream))
                     (Node.Node x) (Array.push-back! &res x)
                     (Node.Nil) ())
              (set! stream (Lazy.force &(tail &stream)))))
        res)))

  (doc transform "
    Alters a stream's state to yield a new stream and maps a function `f` to
    that stream's values.")
  (defn transform [f g h stream]
    (let [n (Stream.next stream)
          s (Stream.state stream)
          ;; When f is passed by reference from a parent context, e.g. replace
          ;; or map the emitted c code sometimes loses track of the reference in the n*
          ;; lambda.
          ;; We copy it here for safety.
          f* @f
          n* (fn [st] (match (~h st)
                             (Step.Done) (Step.Done)
                             (Step.Skip s*) (Step.Skip s*)
                             (Step.Yield x s**) (Step.Yield (f* x) s**)))]
      (Stream.init n* (~g s))))

  (doc replace "
    Replaces `stream` with a new stream by applying `g` to `stream`'s state, to
    yield a new state. The resulting stream applies `h` to process the new
    state.

    ```
    ;; replace an array-backed stream with a stream that iterates successors
    ;; starting from the array's length
    (replace &(fn [arr] (Array.length &arr)) &(fn [s] (Step.Yield @s (+ 1 @s))) (from-array &[1 2 3]))
    => (Stream Fn 3)
    ```")
  (defn replace [g h stream]
    (Stream.transform &id g h stream))

  (doc map "
    Maps a function `f` over a stream, yielding a new stream.

    `f` is only applied to the stream's values--the resulting stream's `state`
    remains unchanged.")
  (defn map [f stream]
    (let [n (Stream.next stream)]
      (Stream.transform f &copy n stream)))

  (doc filter "
    Given a Stream `stream` and a predicate `p`, returns a new Stream
    that only contains elements that satisfy `p`.")
  (defn filter [p stream]
    (let [n (Stream.next stream)
          s (Stream.state stream)
          n* (fn [s] (match (~n s)
                            (Step.Done) (Step.Done)
                            (Step.Skip s*) (Step.Skip s*)
                            (Step.Yield x s**) (if (p &x)
                                                   (Step.Yield x s**)
                                                   (Step.Skip s**))))]
      (Stream.init n* @s)))

  (doc range "
    Returns a stream of a range of values from `start` to `finish`.

    The arguments to this function must implement `inc`.

    ```
    (range 0 10)
    => (Stream Fn 0)
    (force &(head &(range 0 10)))
    => 0
    (force &(tail &(range 0 10)))
    => (Stream Fn 1)
    (force &(tail &(tail &(range 0 10))))
    => (Stream Fn 2)
    ```")
  (todo range "TODO: add a unit test for range")
  (sig range (Fn [a a] (Stream a a)))
  (defn range [start finish]
    (let [n (fn [s] (if (> @s finish)
                        (Step.Done)
                        (Step.Yield @s (inc @s))))]
    (Stream.init n start)))
)

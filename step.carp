;; Copyright 2020 Google LLC
;;
;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;  https://www.apache.org/licenses/LICENSE-2.0
;;
;;  Unless required by applicable law or agreed to in writing, software
;;  distributed under the License is distributed on an "AS IS" BASIS,
;;  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;  See the License for the specific language governing permissions and
;;  limitations under the License.

;; Implementation of the `Step` type, our backing model for Streams.

(doc Step "
  `Steps` define ways to produces successive values. They back the
  implementation of lazy streams.")
(deftype (Step a s) [value a
                     state s
                     new-state (Fn [(Ref s)] s)
                     new-value (Fn [(Ref s)] a)])

(defmodule Step
  (doc from-array "
    Initializes a `Step` from an array.

    The `Step` concludes once the array is exhuasted.")
  (sig from-array (Fn [(Ref (Array z))] (Step (Maybe z) (Array z))))
  (defn from-array [arr]
    (Step.init (Array.nth arr 0)
               @arr
               (fn [s] (Array.suffix s 1))
               (fn [s] (Array.nth s 0))))

  (doc runstep "
    Runs a `Step` to produce a new value, returning a new step.")
  (todo runstep "TODO: use lenses?")
  (sig runstep (Fn [(Ref (Step a s))] (Step a s)))
  (defn runstep [step]
    (let-do [v (Step.value step)
             s (Step.state step)
             ns (Step.new-state step)
             nv (Step.new-value step)]
      (Step.set-state! step (~ns s))
      (Step.set-value! step (~nv s))
      @step))

  (doc runstep! "
    Runs a `Step` in place.")
  (sig runstep! (Fn [(Ref (Step a s))] ()))
  (defn runstep! [step]
    (let-do [s (Step.state step)
             v (Step.value step)
             ns (Step.new-state step)
             nv (Step.new-value step)]
      (Step.set-state! step (~ns s))
      (Step.set-value! step (~nv s))))

  (doc map "
    Maps a function `f` over a `Step`, `step`.")
  (sig map (Fn [(Ref (Fn [a] b)) (Ref (Step a s))] (Step b s)))
  (defn map [f step]
    (let [s @(Step.state step) 
          v @(Step.value step)
          ns @(Step.new-state step)
          nv @(Step.new-value step)]
      (Step.init (~f v)
                 s
        	 ns
                 (fn [x] (~f (nv x))))))
)
